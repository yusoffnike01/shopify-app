import _regeneratorRuntime from "@babel/runtime/regenerator";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import proxy from 'koa-better-http-proxy';
export var PROXY_BASE_PATH = '/graphql';
export var GRAPHQL_PATH_PREFIX = '/admin/api';
export var ApiVersion;

(function (ApiVersion) {
  ApiVersion["July19"] = "2019-07";
  ApiVersion["October19"] = "2019-10";
  ApiVersion["January20"] = "2020-01";
  ApiVersion["April20"] = "2020-04";
  ApiVersion["July20"] = "2020-07";
  ApiVersion["October20"] = "2020-10";
  ApiVersion["Unstable"] = "unstable";
  ApiVersion["Unversioned"] = "unversioned";
})(ApiVersion || (ApiVersion = {}));

export default function shopifyGraphQLProxy(proxyOptions) {
  return /*#__PURE__*/function () {
    var _shopifyGraphQLProxyMiddleware = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx, next) {
      var _ctx$session, session, shop, accessToken, version;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _ctx$session = ctx.session, session = _ctx$session === void 0 ? {} : _ctx$session;
              shop = 'shop' in proxyOptions ? proxyOptions.shop : session.shop;
              accessToken = 'password' in proxyOptions ? proxyOptions.password : session.accessToken;
              version = proxyOptions.version;

              if (!(ctx.path !== PROXY_BASE_PATH || ctx.method !== 'POST')) {
                _context.next = 8;
                break;
              }

              _context.next = 7;
              return next();

            case 7:
              return _context.abrupt("return");

            case 8:
              if (!(accessToken == null || shop == null)) {
                _context.next = 11;
                break;
              }

              ctx["throw"](403, 'Unauthorized');
              return _context.abrupt("return");

            case 11:
              _context.next = 13;
              return proxy(shop, {
                https: true,
                parseReqBody: false,
                // Setting request header here, not response. That's why we don't use ctx.set()
                // proxy middleware will grab this request header
                headers: {
                  'Content-Type': 'application/json',
                  'X-Shopify-Access-Token': accessToken
                },
                proxyReqOptDecorator: function proxyReqOptDecorator(proxyReqOpts) {
                  delete proxyReqOpts.headers.cookie;
                  delete proxyReqOpts.headers.Cookie;
                  return proxyReqOpts;
                },
                proxyReqPathResolver: function proxyReqPathResolver() {
                  return "".concat(GRAPHQL_PATH_PREFIX, "/").concat(version, "/graphql.json");
                }
              })(ctx,
              /*
                We want this middleware to terminate, not fall through to the next in the chain,
                but sadly it doesn't support not passing a `next` function. To get around this we
                just pass our own dummy `next` that resolves immediately.
              */
              noop);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function shopifyGraphQLProxyMiddleware(_x, _x2) {
      return _shopifyGraphQLProxyMiddleware.apply(this, arguments);
    }

    return shopifyGraphQLProxyMiddleware;
  }();
}

function noop() {
  return _noop.apply(this, arguments);
}

function _noop() {
  _noop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _noop.apply(this, arguments);
}